    毫无疑问tij是java编程必读的一本书，深知此书晦涩难懂，需反复咀嚼，方可消化。
    故记录一下阅读时的笔记，便于复习。
    
    **编程最重要的就是思想**

第2章 一切都是对象
    
    1.在使用任何引用前，都必须为其指定一个对象，如果试图访问一个为null的引用，将会报错。
    
    2.java有一个垃圾回收器，用来监视所有new创建的对象，并辨别那些不在被引用的对象，释放这些对象的内存空间。
    
    3.当一个类的成员变量是基本类型时，JVM会默认将其初始化为对应的初值，但是最好自行进行初始化。
    
    4.方法名和参数列表（合起来称为“方法签名”）唯一的标志出某个方法。
    
    5.若返回值类型是void，则return关键字的意思是退出当前方法。
    
    6.static关键字
        创建一个类就是描述这个类的对象的外观和行为。通常来说，我们用new创建对象后，才能调用这个对象的方法。否则，并未获得任何对象。
        通常，我们需要创建一个对象，来访问这个对象的数据或方法，因为非static域和方法必须和必须和某一特定对象相关联。
        
    7.break,continue关键字
        break是强行退出循环，不执行循环中剩余的语句，而continue是结束当前循环，回到循环的起始处，开始下一次循环。
        
第5章

    5.1 用构造器确保初始化
        在对类进行初始化前，会先初始化类中的变量。也即是会先对成员变量进行初始化。
        
    5.4 this关键字返回了当前对象的引用。
        this关键字对于将当前对象传递给其他方法也是很有用。
        还可以用this调用构造器，必须放在构造器的第一行。
        static的含义：static方法就是没有this的方法。
        
    5.5 清理：终结处理和垃圾回收
        finalize的工作原理：一旦垃圾回收器准备释放对象占用的空间，将首先调用其finalize方法，并且在下一次垃圾回收时，才会真正回收对象占用的内存。
                            也就是说，即使调用了finalize方法，对象的内存也不一定会释放。
                            
                            注意：finalize方法只会被调用一次。
                            
         判断对象是否存活：引用计数，可达性分析
         垃圾回收的方式：复制算法,标记-清除算法，标记-整理算法等
    5.7 构造器初始化
        在对构造器进行初始化前，会首先对成员变量进行初始化。
        
        总结一下：对象的创建的过程（加入类为Dog）
            1.构造器实际上也是一个static方法，当首次创建类型为Dog的对象时，Java解释器必须查找类路径，以定位Dog.class文件。
            2.然后载入Dog.class（这将创建一个Class对象），有关静态初始化的所有动作都会执行。因此，静态初始化只在Class对象首次加载的时候进行一次。
            3.当用new Dog()的时候，首先将在堆上为Dog分配足够的存储空间。
            4.这块存储空间会被清零，这就自动的将类中的所有基本类型初始化为默认值，而引用设置为null。
            5.执行所有字段的初始化动作。基本类型初始化为默认值，而引用设置为null。
            6.执行构造器。   
    5.9 枚举类型
        枚举类型里面的常量要大写
        enum事实上就是一个类，并且具有自己的方法。
        
第六章 访问权限控制

    6.1 当编写一个Java源代码文件时，只能有一个public类，且这个类的名称要和源代码文件的名称相同。 Java包名全部使用小写。不用遵守驼峰命名法。      
    6.2 java访问权限修饰词
        public：访问权限最大，其他包内也可以访问。
        protected：也具有包访问权限，但它仍旧不是public的。其它包中的这个类的子类可以访问，
        默认的包访问权限：
        private：只有本类中可以访问。
    6.4 类的访问权限
        注意：类既不可以使private的，也不可以是protected的。
        控制对成员的访问权限有两个原因：第一是为了用户不要触碰那些他们不该触碰的部分，这些部分对于类内部的操作是必要的，但是它并不属于客户端程序员所需接口的一部分。
            第二是为了让类库设计者可以更改类的内部的工作方式，而不必担心这样会对客户端程序员产生重大的影响。
            
第七章 复用类

    7.1 对对象的引用进行初始化的四种方式
        1.在定义对象的地方，这意味着它们总是能够在调用构造器之前进行初始化。
        2.在构造器里面。
        3.使用实例初始化
        4.就是在要使用这些对象之前，这种方式称为惰性初始化。在生成对象不值得或者不必每次都生成对象的情况下，这种方式可以减少额外的负担。
        
    7.2 继承语法：当创建一个类时，总是在继承，因此，除非已明确指出要从其他类中继承，否则就是默认的从Object根类继承。
        由于子类是由extends关键字从父类导出的，所以它可以从其接口中自动获取这些方法，尽管它不能看到这些方法在子类中的显示定义。因此，继承可以看做是对类的复用。
        
        初始化基类：继承并不只是复制基类的接口。当创建了一个导出类的对象时，该对象包含了一个基类的子对象。这个子对象与你直接用基类创建的对象是一样的。
                    继承时构建对象的过程时从基类“向外”扩散的，所以基类在导出类构造器可以访问它之前，就已经完成了初始化。不必为导出类创建构造器，
                    编译器会默认创建一个构造器，该构造器会调用基类的构造器。
                    
                    可以在子类中通过super来调用父类中的方法。
                    在构造器中通过super调用父类的构造器，super必须放在构造器的第一行。
                    
    7.4 结合使用组合和继承 
            许多情况下，清理并不是问题，仅需让垃圾回收器完成这个动作就行。但当必须亲自处理时，就必须要小心了。
            因为垃圾回收器可能永远不会被调用，即使被调用，它也可能以任何它想要的顺序来进行垃圾回收。最好的方式就是
            除了内存以外，不要依赖垃圾回收器去回收任何对象。
            
    7.6 protected关键字：就类用户而言，这是private的，但对于任何继承此类的导出类或其他任何位于同一个包内的的类来说，它却是可以访问的。
    
    7.8 final关键字：修饰与类，字段，方法。
        修饰数据：1.一个永不改变的编译时常量,这类常量必须是基本类型，并且用关键字final修饰。
                  2.一个在运行时被初始化的值，而你不希望它被改变
                  
                  一个既是static又是final的域只占据一段不能改变的存储空间。
                  对于基本类型，final使数值不再改变
                  对于对象引用，final使引用不能改变，而对象自身却是可以改变的。注意：数组也是对象。
                      
            空白final：是指被声明为final却未给定初值的域。无论什么情况，编译器都确保空白final在使用前都必须被初始化。
                必须在域的定义处或者每个构造器中用表达式对final进行赋值，这正是final域再使用前总是被初始化的原因。
                
            final参数：引用参数被final修饰时，无法修改参数引用所指向的对象。
                       基本类型参数被final修饰时，可以读参数，不能修改参数。这一特性主要用来向匿名内部类传递数据。
            
        修饰方法：第一个原因是把方法锁定，以防任何继承类修改它的含义。即方法不会被覆盖。
                  第二个原因是效率，但是现在不用考虑在方法上使用final进行优化，而是想要明确禁止覆盖时，才将方法设置为final了。
            
            final和private关键字：类中的所有private方法都隐式的被制定为final的。由于无法取用private方法，也就无法覆盖它。

         修饰类：final修饰的类不允许被继承，所有final类中的所有方法默认是隐式final的，因为所有的方法都不会被覆盖。
         
    7.9 初始化及类的加载
            每个类的编译代码都存在于它自己的独立文件中。该文件只在需要使用程序代码时才会被加载。

            加载发生于第一次创建类的第一个对象时，当访问static域或static方法时，也会发生加载。
            构造器也是static方法，只是static关键字没有显式的写出来。因此更准确的讲，类是在其任何static成员被访问时被加载的。
            
            在A类上运行java时，所发生的第一件事就是试图访问A.main()方法（一个静态方法），于是加载器开始启动并找出A类的编译代码（在A.class文件中），
            在对它进行加载的过程中，如果发现有基类，会继续对基类进行加载。全部加载完成后，根基类中的static初始化会被执行，然后是下一个导出类，以此类推。
            至此，必要的类加载完毕，对象就可以创建了。首先，对象中的所有基本类型会设为默认值，对象引用会被设为null,然后基类的构造器会被调用。   
            
第八章 多态
    
    8.2.1 方法调用绑定
            将一个方法调用同一个方法调用主体关联起来叫做绑定。
            前期绑定：若在程序执行前进行绑定，叫做前期绑定。前期绑定是不需要选择就默认的绑定方式。        
            后期绑定：在运行时根据对象的类型进行绑定。后期绑定也叫做运行时绑定或动态绑定。
            
            多态其实就是后期绑定
            
            private 方法被自动认为是final的，而且对导出类是屏蔽的。
            
            静态方法不具有多态性，静态方法是与类，而非当个对象相关联的。
            
    8.3 构造器和多态
            构造器实际上也只是static方法，只不过static声明是隐式的。
            不要在构造器内调用被重载的方法。
            
    8.5 用继承进行设计
        一条通用规则：“用继承表达行为上的差异，用字段表达状态上的变化”。
        继承可以保证所有的导出类具有和基类一样的接口，且绝对不会少。
        缺点：导出类中接口的拓展部分不能被基类访问，因此，一旦我们向上转型，就不能调用那些新方法。
        
        RTTI：在运行期间对类型进行检查的行为称作 “ 运行时类型识别 ”（RTTI）。

        一个导出类类型被向上转型成了基类类型，此时导出类具有和基类类型一样的接口，如果想访问导出类的扩展接口，即需要进行向下转型。
        也就是进行强转。
        
    8.6 总结
        多态意味着“不同的形式”。
        
        为了在自己的程序中有效的运行多态乃至面向对象的技术，必须拓展自己的编程视野，使其不仅包括个别类的成员和信息，而且还要包括类与类之间的共同特性
        以及它们之间的关系。尽管这需要极大的努力，但是这么做是值得的，因为它可以带来很多成效：更快的程序开发过程，更好的代码组织，更好的拓展程序以及更容易的代码维护等。
        
第九章 接口

    9.1 抽象类和抽象方法
        包含抽象方法的类叫做抽象类。如果一个类包含抽象方法，那么这个类就必须被限定为抽象的。
        
        抽象类不能被实例化。interface 关键字产生一个完全抽象的类。
        
        接口可以包含域，这些域默认是static和final的。方法默认是public的，无需声明。
        
    9.3 这一章经典，值得多看几遍，对代码进行完全解耦了。
        
        策略设计模式：创建一个能够根据所传递参数对象的不同而具有不同行为的方法，被称为策略设计模式。这类方法包含所有执行的算法中固定不变的部分，而“策略”包含变化的部分。
     
    9.6 适配接口：接口的一种常见用法就是策略模式，编写一个执行某些操作的方法，而该方法接受一个同样是你指定的接口。
                 你主要就是声明：“你可以用任何你想要的对象来调用我的方法，只要你的对象遵循我的接口”。
                 
                 让方法接受接口类型，是一种让任何类都可以对该方法进行适配的方式。这就是使用类而不是接口的强大之处。
                 
                 
                适配器模式：如果你无法修改你想要使用的类，为了使代码进行解耦，可以使用适配器模式。适配器中的代码将接受你所拥有的接口，并产生你所需要的接口。
                 
                 9.6的代码没有敲，以后有机会再看。很经典。
           
           
    9.7 接口中的域：接口中的所有域都是public static final的。要使用大写（多个单词的话中间用下划线分割开）。     
    
    9.9 接口与工厂：接口是实现多重继承的途径。而生成遵循某个接口的对象就是工厂设计模式。
                    对于创建类，几乎是任何时刻，都可以替代为创建一个接口和一个工厂。
                    恰当的原则应该是优先选择类而不是接口。从类开始，如果接口的必须性变得非常明确，那么就进行重构。
    
第十章 内部类

          可以将一个类的定义放在另一个类的定义内部，这就是内部类。
    
    10.1 创建内部类：就是将类的定义放在外围类的里面。
    
    10.2 链接到外部类  
        当生成一个内部类的对象时，此对象就与制造它的外围对象之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何条件。
        内部类可以访问到外围类的所有方法和字段。就像自己拥有他们似得，这带来了很大的方便。（比如 “迭代器模式” 就是一个经典的例子）
        
    10.3 使用.this 与 new 
        在内部类中如果想返回外部类的对象，可以使用外部类的名字后面紧跟圆点和this。
        
        创建某个内部类对象，先创建外部类对象，通过外部类对象.new 内部类来创建。
        
        在拥有外部类对象之前是不可能创建内部类对象的。这是因为内部类对象会暗暗的连接到创建它的外部类对象上。
        但是如果是嵌套类（静态内部类），就不需要外部类对象的引用。
        
    10.6 匿名内部类
        语法：创建一个实现了某接口(继承了某个类)的匿名的对象，通过new表达式返回的引用被自动向上转型为对接口（类）的引用。  
        在匿名类中定义字段时，还能够对其执行初始化操作。
        
    10.7 嵌套类
        如果不需要内部类对象与其外部类之间的联系，可以将内部类声明为static。称为嵌套类。
        
        普通的内部类对象隐式的保存了一个引用，用于指向它的外围类对象。
        
        嵌套类意味着：
            （1）要创建嵌套类的对象，并不需要其外围类的对象。
            （2）不能从嵌套类的对象中访问非静态的外围类对象。
            
    10.8 为什么需要内部类
        一般来说，内部类继承自某个类或实现了某个接口。
        
        如果只是需要一个接口的引用，为什么不通过外围类来实现那个接口呢？ 答案是：“如果这能满足需求，就应该这样做”。
        但是这样的话相比于内部类，享用不到接口带来的方便，有时候需要接口的实现。
        使用内部类最吸引人的原因：每个内部类都能独立的继承自一个接口的实现，所以无论外围类是否已经继承了某个（接口）的实现，对于内部类都没有影响。
        
        使用内部类，还可以获得以下特性：
            1.内部类可以有多个实例，每个实例都有自己的状态信息，并且与外围类的信息相互独立。
            2.在单个外围类中，可以让多个内部类以不同的方式都实现同一个接口，或继承同一个类。
            3.内部类并没有令人疑惑的“is-a”关系，它就是一个独立的实体。
            
 第十一章 持有对象
    
    Object默认的toString()将打印类名，后面紧跟该对象的散列码的无符号十六进制表示（这个散列码是通过hashCode()方法产生的）。

    Set:
        HashSet:无序，不重复，存储速度快。 底层使用了散列函数。
        TreeSet:无序，不重复，存储速度慢与HashSet。因为TreeSet维持内部排序。
        LinkHashSet:不重复，按照添加顺序存储。
        
    Map:
        键和值并不是按照添加的顺序进行排序，因为HashMap实现使用的是一种非常快的算法来控制顺序。
        
        foreach的底层是迭代器，只要一个类实现了Iterable接口，便可以使用foreach对类中存储的元素进行遍历。
           
 第十二章 异常
 
    11.1 概念 
       一般情况下，我们总是用new在堆上创建对象，所有的标准异常类都有两个构造器，一个是默认的无参构造器，还一个是接受一个字符串参数，
       以便把相关信息放入到异常对象的构造器，
       
       对于异常，要么进行try catch掉，要么抛出来，交给调用它的方法进行处理。
       
 第十三章 字符串
  
    String是一个不可变类。如果要对String进行频繁的拼接的话，就是用StringBuilder()，StringBuffer不是线程安全的。
    13.3 无意识的递归  使用toString（）打印出内存地址，方法内部就调用Object.toString()。而不是this.toString()。
       
 第十四章 类型信息（RTTI）
   
     
    	14.1 RTTI：Run-Time Type Identification-----运行时类型信息。
    		在java中，所有的类型转换都是在运行时进行进行检查的。这也是RITT名字的含义：在运行时，识别一个对象的信息。
    		
    	14.2 Class对象： 
    		java使用、class对象来处理RITT,每个类都有一个Class对象，每当编写并编译一个类就会产生一个Class对象。为了生成这个类的对象，运行这个程序测java虚拟机（JVM）将会使用被称为”类加载器“ 的子系统。
    
    	14.3 
    	    1.所有的类第一次被运行时，都会动态的加载到JVM中，类加载器会首先检查这个类的Class对象是否已经加载，如果没有加载，就会找到这个类的.class文件，加载这个类的字节码文件。
    	一旦某个类的Class对象被加载到内存中，它就会被用来创建这个类的所有对象。
    	如果内存中有这个类的Class对象，那么可以使用Class.forName(全包名)加载这个类，返回的是这个类的对象的引用。但是如果已经有了一个感兴趣的类型的对象，就可以通过调用getClass（）方法获取Class引用。
    
            2. 如果一个static final值是编译期常量，那么这个值不需要被初始化就可以被读取。
            如果一个static域不是final的，那么使用这个域之前需要先链接（为这个域分配存储空间）和初始化（初始化存储空间），因为它不是编译期常量。
        
            3. 泛型中<？>就是通配符，代表的是“任何事物”
    		<? Extends T>？代表T的所有子类类型，这个泛型的意思就是支持T的所有子类型。
    		<? Super T>？代表T的所有基类类型，这个泛型的意思就是支持T的所有基类类型。
    
    	    4. 添加泛型语法的原因是为了提供编译时期进行检查，避免操作有误，而到了后期运行时才发现。

    	14.5 instanceof与class的等价性：instanceof表示了类型的概念，instanceof表示“你是这个类吗？或者你是这个类的子类吗？”,而class表示就是这个类。
    	
    	14.6 反射
    	
    	14.7 动态代理需看一下。     
       
        14.8 空对象：
        
        14.9 接口和类型信息
            通过反射，我们可以调用所有方法，甚至是private方法，在设计类时，没有任何办法(用内部类，匿名内部类都不行)可以限制通过反射去访问所有的方法，
            通过反射我们也可以访问私有的字段并进行修改。（但是被final修饰的字段在遭遇修改时是安全的，
            在运行时系统会在不抛异常的情况下接受任何修改尝试，但实际上并不会修改，也就是说反射不能修改私有的final域）。
       
 第二十一章 并发
  
  	21.1. 并发的多面性
  		a. 更快的执行
  			i. 并发通常是提高运行在单处理器上的程序的性能
  			ii. 在单处理器运行的并发程序开销确实应该比该程序的所有部分都顺序执行的开销大。
  			因为增加了上下文切换的代价。（从一个任务切换到另一个任务）。表面上看来，将程序中的所有部分度当做单个的任务运行好像开销是要小一点，并且可以节省上下文切换的代价。
  			iii. 但是会发生阻塞。通常是I/O，一旦某个任务出现阻塞，那么整个程序都不能运行。而在并发程序中，那么当一个任务阻塞时，其他任务还能继续执行。从性能的角度看，如果没有阻塞，那么在单处理器的机器上使用并发就没有意义。
  			iv. 多任务操作系统会通过周期性的将CPU从一个进程切换到另一个进程，来实现同时运行多个程序。不同程序在操作系统之间是相互隔开的，彼此之间互不干涉。
  	
  		b. 改进代码设计
  			i. java的线程是抢占式的，这表明调度机制会周期性的中断线程，将上下文切换到另一个线程，从而为每个线程都提供时间片，使得每个线程都会分配到数量合理的时间去驱动它的任务。
  			ii. 在用消息系统工作时，并发时一种非常有用的模型，因为他是实际发生的模型。
  			通常，线程使你能够创建更加松耦合的设计，否则，你的代码中各个部分都必须显式的关注那些通常可以由线程来处理的任务。
  	
  	21.2. 基本的线程机制：
  		并发编程使我们可以将程序划分为多个分离的独立运行的任务。一个线程就是在进程中的一个单一的顺序控制流，因此，单个线程，可以拥有多个并发执行的任务。
  		在使用线程时，CPU将轮流的为每个任务分配其占用时间。
  		
  		a. 定义任务
  		Thread.yield()方法： 是对线程调度器（java线程机制的一部分，可以将CPU从一个线程转移给另一个线程）的一种建议，它在声明：“我已经执行完生命周期中重要的部分了，次刻正式切换给其他任务执行一段时间的大好时机”；
  		Run()方法，并无特殊之处——它并不会产生任何内在的线程能力。要实现线程行为，必须显示的将一个任务附着到线程上。
  
  	    21.2.3. 使用Executor
            a. Executor执行器创建和管理对象，通过executor的静态方法创建CashedThreadPool并返回ExecutorService，
                CashedThreadPool将为每个任务创建一个线程。非常常见的是单个的Executor被用来创建和管理系统中的所有任务。任务执行完之后调用shutDown方法关闭缓冲池，防止新任务被提交给这个Executor。
            b. FixedThreadPool可以创建有限的线程集，这样可以一次性的预先执行高昂的线程分配。可以节省时间，不用为每个任务都固定的创建线程的开销。
            c. CashedThreadPool在程序执行过程中通常会创建于所需数量相同的线程，然后在它回收旧线程时停止创建新的线程。
            d. SingleThreadExecutor就像是线程数量为1的FixedThreadPool,,如果向SingleThreadExecutor提交了多个任务，那么这些任务将等待，每个任务都会在下一个任务开始之前运行结束，所有的任务用的都是同一个线程。
                因此，SingleThreadExecutor会序列化所有已经提交给他的任务，并会维护它自己（隐藏）的悬挂任务队列。SingleThreadPool确保任意时刻在任何线程中都只有唯一的任务在运行。
  
             注意：在任何线程池中，现有线程在可能的情况下，都会被自动复用。   
                
  	    21.2.4. 从任务中获取返回值
  		    a. Runnable是执行工作的独立任务，没有返回值。要想有返回值，可以实现Callable接口。类型参数是call() 不是run();调用的话是submit(),而不是start();返回值是future对象，调用future的get()方法查看结果。
  
  	    21.2.5. 休眠
  		    a. Sleep()方法可以可以使当前线程休眠，设置睡眠时间，当睡眠结束时，次线程又会继续执行，并没有放弃锁。
  
  	    21.2.7 让步
  		    a. Thread.yield()方法的意思是当前的线程完成的差不多了，可以让别的线程来使用CPU了，但是这只是一个暗示，没有任何机制会保证它会被采纳。当调用yield()时，你也是在建议具有相同优先级的其他线程可以运行。所以说，实际上，yield()经常被误用。
  
  	    21.2.8. 后台线程（守护线程）
            a. 是指在程序运行的时候在后台提供一种通用的服务的线程，当所有的非后台线程执行结束后，所有的后台线程也会终止。Main()就是一个非后台线程。在调用start()方法前通过Thread.serDaemon(true)将thread设置为后台线程。
            b. 如果一个线程是后台线程，那么创建的任何线程都会自动的被设置为后台线程。，尽管没有被显示的设置为后台线程，但它们的确是后台线程。
            c. 只要非后台线程还在执行，程序就不会终止。main()就是一个非后台线程，当所有的非后台线程执行结束时，程序也就终止了，同时会杀死进程中的所有后台线程。
            c. finally一般情况下是一定要执行的。但是如果是守护线程的finally，就不一定了，因为守护线程在所有
            非后台线程执行完毕后会立刻终止。比如守护线程正在睡眠或等待，而非后台线程已经执行完毕。
  
  	    21.2.9. 继承Thread类
            对于一个实现了Runnable借口，或继承了Thread的类，可以在构造器中调用start()方法来开启一个线程，每当创建一个对象，就会开启一个线程。
            注意 ： 在构造器中开启一个线程可能会有问题，因为另一个任务可能会在构造器结束之前开始执行，这意味着该任务能够访问处于不稳定状态的对象。这也是优选Executor而不是显式的创建Thread对象的另一个原因。
      
        21.2.10 术语
            在Java中，Thread类自身不执行任何操作，它只是驱动赋予它的任务。
            你创建任务，并通过某种方式将一个线程附着到线程上，以使得在这个线程可以驱动任务。
            
  	    21.2.11. 加入一个线程
            a. 如果某个线程在另一个线程t上调用t.join()，那么该线程将会挂起，直到目标线程t结束才恢复。（即t.isAlive()返回为false）
            b.也可以在调用join()时带上一个超时参数，这样如果这个目标线程在这段时间内都没有结束的话，join()方法总能返回。
            c. 对join方法的调用可以被中断，做法是在调用线程上调用interrupted()方法，这是需要用到try-catch语句。
  		
  		21.2.14. 捕获异常
  	
  	21.3 共享受限资源
  		21.3.1 不正确的访问资源
  			i. 如果多个线程访问同 一个共享资源就有可能会发生线程安全问题。
  			ii. 在java中，递增不是原子性的操作，因为递增可能需要多个操作，并且在递增过程中任务可能别线程机制挂起。因此，如果不保护任务，即使单一的递增也不是安全的。
  			iii.线程调度机制是不确定性的，我们不能确定是下一个执行的线程会是哪一个线程。但可以通过setPriority()和yield()来给线程调度器提供建议。

  		21.3.2. 解决共享资源竞争
  		
  			1. 锁：对特定对象来说，其所有synchronized方法共享一个一个锁，这可以防止多个任务同时访问被编码为对象内存。对象进行加锁时，JVM负责进行跟踪对象加锁的次数，
  			    如果一个对被解锁，其计数变为0，在任务第一次给对象加锁时，计数变为1。每当相同的任务在这个对象上获得锁时，计数都会递增。
  			    只有获得了锁的任务才能继续获取多个锁。每当任务离开一个synchronized方法，计数递减，当计数为零的时候，锁被完全释放，此时别的任务就可以使用此资源。
          
  	        2. 使用显式的lock对象
                a. Lock对象必须被显式的创建，锁定和释放。虽然比内建的锁相比，代码缺乏优雅性，但是它更加灵活，
                b. 只有在解决特殊问题时才会使用显式的lock对象。例如：使用synchronized关键字不能尝试着获取锁且最终获取锁会失败，或者尝试着获取锁一段时间，然后放弃它。
                c. 显式的Lock对象在加锁和释放锁方面，相比于内建的synchronized锁来说，还赋予了你更细粒度的控制力。
                d. tryLock()：尝试获取锁，如果获取到了，返回true,计数+1，如果没获取到，返回false。还可以设置尝试获取锁的时间。指定时间内没有获取到锁，返回false.
  
  	    21.3.3 原子性和易变性
  	    
            a. “原子操作不需要进行同步控制”是不正确的。
                 原子操作是不能被线程调度机制中断的操作。一旦操作开始，那么一定会在可能发生的“上下文切换前”（下一个线程开始前）执行完毕。
          
            b. 原子性可以应用于除long和double之外的所有的基本类型的数据上的“简单操作”,long 和double虽是原子操作，
                但是JVM可以将64位的（long 和double）读取和写入当做两个分离的32位操作来执行，着就产生了一个读取和写入操作中间发生了上下文切换，
                就会不安全。如果使用volatile关键字修饰，就会获得原子性。就安全了。
          
            c. volatile确保了应用中的可视性，如果你将一个域声明为了volatile的，那么重要对这个域产生了写入操作，那么所有的操作都会都可以看到这个修改。
                即便使用了本地缓存，volatile域会立即别写入到主存中去，而读取操作就发生在主存中。
        
            d. 在非volatile域上的原子操作不必刷新到主存中去，（可以暂时性的放在本地处理器的缓存中）因此其他读取该域的任务也不必看到这个新值。
                如果多个任务在同时访问某个域，那么这个域就应该是volatile的。当然也可以使用同步来解决，因为同步会导致刷新主存。使用了同步之后，就不用设置为volatile的了。
         
            e. 使用volatile而不是synchronized的唯一安全的情况下是类中只有一个可变的域。第一选择应该是使用synchronized关键字，这是最安全的。
      
        21.3.4 原子类：AtomicInteger,AtomicLong,AtomicReference等特殊类型的原子性变量类。
            一般情况下，使用锁就行了。当涉及到性能调优时，原子类大有用处。
            
        21.3.5 临界区
            synchronized(syncObject) {
                // the code can be accessed;
                // by only one task at one time;
            }  
            称为同步控制块；            
    
        21.3.7 线程本地存储
        
            a. 防止任务在共享资源上产生冲突的第二种方式是根除对变量的共享。本地线程存储是一种自动化机制，可以为使用为使用相同变量的每个不同的线程都创建不同的存储。
                因此，如果你有5个线程都要使用变量x所表示的对象，那么线程本地存储就会在创建5个用于存储x的存储快。主要是，它们使得你可以将状态和线程关联起来。

            b. ThreadLocal保证不会出现竞争条件。
  	
  	21.4 终结任务
  	    21.4.2 在阻塞时终结
  	    
            a. 线程状态
                i. 新建 ： 一旦线程被创建，就会短暂的处在这状态，此时，线程已经完成了初始化，并有资格获取CPU时间了，之后调度器将把这个线程转变为可运行状态或阻塞状态。
                ii. 就绪 ： 在这种状态，只要CPU分配了时间给线程，那么线程就会执行。不同于阻塞和死亡状态。
                iii. 阻塞 ： 线程能够运行，但是调度器会忽略线程，不会给线程分配CPU时间，直到线程重新进入就绪状态，它才有可能重新执行。
                iv. 死亡 ： 处于死亡状态的线程将不再是客调度的，一般是从run()中执行结束，也可以是被中断。死亡之后，不再运行。
        
            b. 进入阻塞状态
                i. Sleep(milliseconds)进入睡眠状态。
                ii. Wait()进入等待状态，直到被唤醒（notify(),notityAll()）。唤醒之后进入救赎状态。
                iii. 一个对象获得了锁，那么另一个线程去获得这个对象的同步方法时，将处于等待状态。
        
            c. 在较早的代码中，可以使用suspend()或resume()方法来阻塞和唤醒线程，但是已经被废止了，因为可能导致死锁。Stop()也被废止了，因为它不释放线程获得的锁。
          
            d. 一个线程可以多次获得某个对象的锁，也就是说线程A获得获得了对象B的锁，在线程A运行的同时还可以多次获得对象B的锁。即一个任务可以调用在同一个对象中的其他synchronized方法，即使这个任务已经获得锁了。

        21.4.3 中断
            
            a.如果一个线程处于sleep()或awit()状态时，那么可能会抛出InterruptedException();对该线程调用Thread.interrupted()
                可以捕获到该异常。
             
                中断多个任务：Executors.shutdownNow()将会发送一个interrupted()给它启动的所有线程。
                
                中断单个任务：Executors.submit(Runnable task)返回一个Future<?>,Future.cancel()方法可以中断单个的线程。
            io处于阻塞状态时，可调用Executors.shutdownNow()方法解除阻塞状态，然后就可以关闭io。
             
    	21.4.4 检查中断
  		    a. 注意，当你在线程上调用interrupted时，中断发生的唯一时刻是在任务要进入到阻塞操作中，或者已经在阻塞操作内部，IO不可中断和被阻塞的synchronized方法是不可中断的。不是很理解。见 thinkingInJava p700
   
    21.5 线程之间的协作
  	    21.5.1 Wait() 和notifyAll()
            a. 调用sleep()的时候并没有释放锁，调用yield()的时候也没有释放锁。调用wait()的时候，线程被挂起，锁被释放。

            b. Wait(),notify(),notifyAll()不是Thread类的方法，而是基类Object类中的方法。所以无论在什么地方地方都可以使用，但是非同步方法中使用会抛出异常，意思就是说：在使用执行这三个方法的任务在调用这些方法前要先获得对象的锁。
  			
  		21.5.2 notify() 和 notifyAll()
  			
  
  	15. 检查中断
  		a. 注意，当你在线程上调用interrupted时，中断发生的唯一时刻是在任务要进入到阻塞操作中，或者已经在阻塞操作内部，IO不可中断和被阻塞的synchronized方法是不可中断的。不是很理解。见 thinkingInJava p700
  
  	16. Wait() 和notifyAll()
  		a. 调用sleep()的时候并没有释放锁，调用yield()的时候也没有释放锁。调用wait()的时候，线程被挂起，锁被释放。
  		b. Wait(),notify(),notifyAll()不是Thread类的方法，而是基类Object类中的方法。所以无论在什么地方地方都可以使用，但是非同步方法中使用会抛出异常，意思就是说：在使用执行这三个方法的任务在调用这些方法前要先获得对象的锁。
 		
  		不理解之处：volatile关键字

       
       
       
       
       栈 ：局部变量表，栈帧等信息
       堆：几乎所有的对象都是在堆上分配，
       方法区：类的信息，静态常量等信息
       
       引用计数
       可达性分析算法
       
       标记清除 缺点：效率不高，产生不连续的碎片
       复制算法：eden空间，s1,s2 
       标记整理：
       
       垃圾回收：将堆分为新生代和老年代
       新生代：复制算法
       老年代：标记清除或者标记整理算法。
       
       
       
 
    